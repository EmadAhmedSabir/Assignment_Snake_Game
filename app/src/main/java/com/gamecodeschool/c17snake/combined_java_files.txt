File: C:\Users\Admin\Projects\Emad\Assignment_Snake_Game\app\src\main\java\com\gamecodeschool\c17snake\Apple.java
package com.gamecodeschool.c17snake;

import android.content.Context;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.Canvas;
import android.graphics.Paint;
import android.graphics.Point;
import java.util.Random;
import android.graphics.PorterDuff;
import android.graphics.PorterDuffColorFilter;
import android.graphics.Color;

class Apple implements Drawable{

    private final Point location = new Point();
    private final Point mSpawnRange;
    private int mSize;

    private Bitmap mOriginalBitmap;

    private Bitmap mBitmapApple;

    private final Context context;
    private static final int initialX = -10;
    public Apple(Context context, Point sr, int s) {
        this.context = context;
        mSpawnRange = sr;
        mSize = s;
        location.x = initialX;

        mOriginalBitmap = BitmapFactory.decodeResource(context.getResources(), R.drawable.apple);
        mBitmapApple = Bitmap.createScaledBitmap(mOriginalBitmap, s, s, false);
    }

    void spawn(){
        Random random = new Random();
        location.x = random.nextInt(mSpawnRange.x - 1) + 1;
        location.y = random.nextInt(mSpawnRange.y - 1) + 1;
    }
    void spawn(int s){
        Random random = new Random();
        location.x = random.nextInt(mSpawnRange.x - 1) + 1;
        location.y = random.nextInt(mSpawnRange.y - 1) + 1;
        mBitmapApple = Bitmap.createScaledBitmap(mOriginalBitmap, mSize, mSize, false);
        changeColor(s);
    }
    void changeColor(int s){

        Bitmap tempBitmap = Bitmap.createBitmap(mSize, mSize, Bitmap.Config.ARGB_8888);
        Canvas canvas = new Canvas(tempBitmap);
        Paint paint = new Paint();
        int newColor = s;
        PorterDuffColorFilter colorFilter = new PorterDuffColorFilter(newColor, PorterDuff.Mode.SRC_ATOP);
        paint.setColorFilter(colorFilter);

        canvas.drawBitmap(mBitmapApple, 0, 0, paint);

        mBitmapApple = tempBitmap;

    }

    Point getLocation(){
        return location;
    }
    @Override
    public void draw(Canvas canvas, Paint paint){
        canvas.drawBitmap(mBitmapApple,
                location.x * mSize, location.y * mSize, paint);

    }

}
File: C:\Users\Admin\Projects\Emad\Assignment_Snake_Game\app\src\main\java\com\gamecodeschool\c17snake\Drawable.java
package com.gamecodeschool.c17snake;

import android.graphics.Canvas;
import android.graphics.Paint;

interface Drawable {
    void draw(Canvas canvas, Paint paint);
}


File: C:\Users\Admin\Projects\Emad\Assignment_Snake_Game\app\src\main\java\com\gamecodeschool\c17snake\Ghost.java
package com.gamecodeschool.c17snake;

import android.content.Context;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.Paint;
import android.graphics.Point;
import android.graphics.Rect;
import java.util.Random;

public class Ghost {
    private final int SIZE;
    private final int SPEED;
    private Point position;
    private final Point snakePosition;
    private final Rect bounds;
    private final Paint paint;
    private boolean isFollowing;

    public Ghost(Context context, int size, int speed, Rect gameBounds, Point snakePosition) {
        SIZE = size;
        SPEED = speed;
        bounds = gameBounds;
        position = new Point();
        this.snakePosition = snakePosition;
        paint = new Paint();
        paint.setColor(Color.RED);
        resetPosition();
    }

    public void draw(Canvas canvas) {
        canvas.drawRect(position.x, position.y, position.x + SIZE, position.y + SIZE, paint);
    }

    public void update() {
        move();
        checkBoundaries();
    }

    private void move() {
        if (isFollowing) {
            // Calculate the direction to move towards the snake
            int dx = Integer.compare(snakePosition.x, position.x);
            int dy = Integer.compare(snakePosition.y, position.y);

            // Move the ghost towards the snake
            position.x += dx * SPEED;
            position.y += dy * SPEED;
        } else {
            // Move the ghost randomly
            int dx = new Random().nextInt(3) - 1;
            int dy = new Random().nextInt(3) - 1;
            position.x += dx * SPEED;
            position.y += dy * SPEED;

            // Check if the ghost is close enough to the snake to start following
            if (Math.abs(position.x - snakePosition.x) <= 3 * SIZE && Math.abs(position.y - snakePosition.y) <= 3 * SIZE) {
                isFollowing = true;
            }
        }
    }

    private void checkBoundaries() {
        if (position.x < bounds.left) {
            position.x = bounds.left;
        } else if (position.x + SIZE > bounds.right) {
            position.x = bounds.right - SIZE;
        }

        if (position.y < bounds.top) {
            position.y = bounds.top;
        } else if (position.y + SIZE > bounds.bottom) {
            position.y = bounds.bottom - SIZE;
        }
    }

    public Rect getBounds() {
        return new Rect(position.x, position.y, position.x + SIZE, position.y + SIZE);
    }

    public Point getPosition() {
        return position;
    }

    public void resetPosition() {
        position.x = new Random().nextInt(bounds.right - SIZE);
        position.y = new Random().nextInt(bounds.bottom - SIZE);
        isFollowing = false;
    }

    public boolean detectCollision(Rect snakeRect) {
        return getBounds().intersect(snakeRect);
    }
}
File: C:\Users\Admin\Projects\Emad\Assignment_Snake_Game\app\src\main\java\com\gamecodeschool\c17snake\Movable.java
package com.gamecodeschool.c17snake;

interface Movable {
    void move();
}


File: C:\Users\Admin\Projects\Emad\Assignment_Snake_Game\app\src\main\java\com\gamecodeschool\c17snake\Snake.java
package com.gamecodeschool.c17snake;

import android.content.Context;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.Matrix;
import android.graphics.Paint;
import android.graphics.Point;
import android.graphics.Rect;
import android.view.MotionEvent;
import java.util.ArrayList;
import android.os.Handler;

class Snake implements Drawable, Movable {

    private final ArrayList<Point> segmentLocations;
    private final int segmentSize;
    private final Point moveRange;
    private int halfWayPoint;
    private enum Heading {
        UP, RIGHT, DOWN, LEFT
    }

    private Heading heading = Heading.RIGHT;
    private Bitmap headBitmapRight;
    private Bitmap headBitmapLeft;
    private Bitmap headBitmapUp;
    private Bitmap headBitmapDown;
    private Bitmap bodyBitmap;
    private final int[] animationSequence = {R.drawable.pacman1, R.drawable.pacman2, R.drawable.pacman3};
    private int currentAnimationFrame = 0; // Index of the current frame in the animation sequence
    private Context context; // Context reference for resource loading
    private static final long ANIMATION_DELAY_MS = 400; //delay? doesn't do anything
    private Handler animationHandler;

    Snake(Context context, Point moveRange, int segmentSize) {
        segmentLocations = new ArrayList<>();
        this.segmentSize = segmentSize;
        this.moveRange = moveRange;
        this.context = context;

        // Load the head bitmaps
        loadHeadBitmap(animationSequence[currentAnimationFrame]);

        // Load and process the body bitmap
        bodyBitmap(context, segmentSize);

        // Calculate the halfway point
        calculateHalfWayPoint(moveRange, segmentSize);
        animationHandler = new Handler();
        startAnimation();
    }

    private void loadHeadBitmap(int resId) {
        Bitmap headBitmap = BitmapFactory.decodeResource(context.getResources(), resId);
        // Process the bitmap as needed (e.g., resize, rotate, change color)
        headBitmap = processHeadBitmap(headBitmap, segmentSize);
        // Update all head bitmaps with the loaded bitmap
        headBitmapRight = headBitmap;
        headBitmapLeft = flipBitmap(headBitmap);
        headBitmapUp = rotateBitmap(headBitmap, -90);
        headBitmapDown = rotateBitmap(headBitmap, 90);
    }

    private Bitmap processHeadBitmap(Bitmap bitmap, int segmentSize) {
        return Bitmap.createScaledBitmap(bitmap, segmentSize, segmentSize, false);
    }

    private Bitmap rotateBitmap(Bitmap bitmap, float degrees) {
        Matrix matrix = new Matrix();
        matrix.preRotate(degrees); // Rotate by the specified degrees
        return Bitmap.createBitmap(bitmap, 0, 0, bitmap.getWidth(), bitmap.getHeight(), matrix, true);
    }
    private void startAnimation() {
        // Schedule the animation to update at a fixed delay
        animationHandler.postDelayed(new Runnable() {
            @Override
            public void run() {
                // Update the head bitmap for animation
                updateHeadBitmap();
                // Restart the animation loop
                startAnimation();
            }
        }, ANIMATION_DELAY_MS);
    }


    private Bitmap flipBitmap(Bitmap bitmap) {
        Matrix matrix = new Matrix();
        matrix.preScale(-1, 1);
        return Bitmap.createBitmap(bitmap, 0, 0, bitmap.getWidth(), bitmap.getHeight(), matrix, true);
    }

    private void bodyBitmap(Context context, int segmentSize) {
        // Create a circular bitmap with a yellow color for the body
        bodyBitmap = Bitmap.createBitmap(segmentSize, segmentSize, Bitmap.Config.ARGB_8888);
        Canvas canvas = new Canvas(bodyBitmap);
        Paint paint = new Paint();
        paint.setColor(Color.YELLOW);
        canvas.drawCircle(segmentSize / 2f, segmentSize / 2f, segmentSize / 2f, paint);
    }

    private void calculateHalfWayPoint(Point moveRange, int segmentSize) {
        halfWayPoint = moveRange.x * segmentSize / 2;
    }

    void reset(int width, int height) {
        heading = Heading.RIGHT;
        segmentLocations.clear();
        segmentLocations.add(new Point(width / 2, height / 2));
    }

    @Override
    public void draw(Canvas canvas, Paint paint) {
        if (!segmentLocations.isEmpty()) {
            Bitmap headBitmap = headBitmapRight;
            switch (heading) {
                case RIGHT:
                    headBitmap = headBitmapRight;
                    break;
                case LEFT:
                    headBitmap = headBitmapLeft;
                    break;
                case UP:
                    headBitmap = headBitmapUp;
                    break;
                case DOWN:
                    headBitmap = headBitmapDown;
                    break;
            }

            drawHead(canvas, paint, headBitmap, 0);

            for (int i = 1; i < segmentLocations.size(); i++) {
                // Draw the circular yellow body bitmap
                canvas.drawBitmap(bodyBitmap,
                        segmentLocations.get(i).x * segmentSize,
                        segmentLocations.get(i).y * segmentSize, paint);
            }
        }
    }

    private void drawHead(Canvas canvas, Paint paint, Bitmap bitmap, int segmentIndex) {
        if (segmentIndex < segmentLocations.size()) {
            Point segment = segmentLocations.get(segmentIndex);
            int x = segment.x * segmentSize;
            int y = segment.y * segmentSize;
            canvas.drawBitmap(bitmap, x, y, paint);
        }
    }

    @Override
    public void move() {
        for (int i = segmentLocations.size() - 1; i > 0; i--) {
            segmentLocations.get(i).x = segmentLocations.get(i - 1).x;
            segmentLocations.get(i).y = segmentLocations.get(i - 1).y;
        }
        Point p = segmentLocations.get(0);
        switch (heading) {
            case UP:
                p.y--;
                break;
            case RIGHT:
                p.x++;
                break;
            case DOWN:
                p.y++;
                break;
            case LEFT:
                p.x--;
                break;
        }

        // Update the head bitmap for animation
        updateHeadBitmap();
    }

    private void updateHeadBitmap() {
        currentAnimationFrame = (currentAnimationFrame + 1) % animationSequence.length;
        loadHeadBitmap(animationSequence[currentAnimationFrame]);
    }

    boolean detectDeath() {
        if (segmentLocations.get(0).x < 0 || segmentLocations.get(0).x >= moveRange.x ||
                segmentLocations.get(0).y < 0 || segmentLocations.get(0).y >= moveRange.y) {
            return true;
        }

        Point head = segmentLocations.get(0);
        for (int i = 1; i < segmentLocations.size(); i++) {
            if (head.equals(segmentLocations.get(i))) {
                return true;
            }
        }
        return false;
    }

    boolean checkDinner(Point location) {
        if (segmentLocations.get(0).equals(location)) {
            segmentLocations.add(new Point(-10, -10));
            return true;
        }
        return false;
    }

    void switchHeading(MotionEvent motionEvent) {
        if (motionEvent.getX() >= halfWayPoint) {
            clockwise();
        } else {
            counterClockwise();
        }
    }

    private void clockwise() {
        switch (heading) {
            case UP:
                heading = Heading.RIGHT;
                break;
            case RIGHT:
                heading = Heading.DOWN;
                break;
            case DOWN:
                heading = Heading.LEFT;
                break;
            case LEFT:
                heading = Heading.UP;
                break;
        }
    }

    private void counterClockwise() {
        switch (heading) {
            case UP:
                heading = Heading.LEFT;
                break;
            case LEFT:
                heading = Heading.DOWN;
                break;
            case DOWN:
                heading = Heading.RIGHT;
                break;
            case RIGHT:
                heading = Heading.UP;
                break;
        }
    }

    Rect getHeadBounds() {
        // Calculate the bounds of the snake's head based on its position
        int left = segmentLocations.get(0).x * segmentSize;
        int top = segmentLocations.get(0).y * segmentSize;
        int right = left + segmentSize;
        int bottom = top + segmentSize;
        return new Rect(left, top, right, bottom);
    }

    public Point getHeadPosition() {
        return segmentLocations.get(0);
    }
}
File: C:\Users\Admin\Projects\Emad\Assignment_Snake_Game\app\src\main\java\com\gamecodeschool\c17snake\SnakeActivity.java
package com.gamecodeschool.c17snake;

import android.annotation.SuppressLint;
import android.app.Activity;
import android.graphics.Point;
import android.os.Bundle;
import android.view.Display;
import android.widget.LinearLayout;
import android.widget.TextView;

public class SnakeActivity extends Activity {

    SnakeGame mSnakeGame;
    LinearLayout SnackGameView;
    @SuppressLint("StaticFieldLeak")
    public static TextView btnPauseOrResume;
    private TextView txtScore;
    private TextView txtHighScore;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        SnackGameView = findViewById(R.id.idSnakeGameView);
        btnPauseOrResume = findViewById(R.id.btnPauseOrResume);
        txtScore = findViewById(R.id.txtScore);
        txtHighScore = findViewById(R.id.txtHighScore);

        Display display = getWindowManager().getDefaultDisplay();

        Point size = new Point();
        display.getSize(size);

        // Pass the TextViews to the SnakeGame constructor
        mSnakeGame = new SnakeGame(this, size, txtScore, txtHighScore);

        SnackGameView.addView(mSnakeGame);
    }

    @Override
    protected void onResume() {
        super.onResume();
        mSnakeGame.resume();
    }

    @Override
    protected void onPause() {
        super.onPause();
        mSnakeGame.pause();
    }
}
File: C:\Users\Admin\Projects\Emad\Assignment_Snake_Game\app\src\main\java\com\gamecodeschool\c17snake\SnakeGame.java
package com.gamecodeschool.c17snake;

import android.annotation.SuppressLint;
import android.content.Context;
import android.content.res.AssetFileDescriptor;
import android.content.res.AssetManager;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.Paint;
import android.graphics.Point;
import android.graphics.Rect;
import android.media.AudioAttributes;
import android.media.SoundPool;
import android.view.MotionEvent;
import android.view.SurfaceHolder;
import android.view.SurfaceView;
import android.widget.TextView;

import java.io.IOException;

class SnakeGame extends SurfaceView implements Runnable {

    // Objects for the game loop/thread
    private static Thread mThread = null;
    // Control pausing between updates
    private long mNextFrameTime;
    // Is the game currently playing and or paused?
    private static volatile boolean mPlaying = false;
    private volatile boolean mPaused = true;

    // for playing sound effects
    private final SoundPool mSP;
    private int mEat_ID = -1;
    private int mCrashID = -1;

    // The size in segments of the playable area
    private final int NUM_BLOCKS_WIDE = 15;
    private final int mNumBlocksHigh;
    private int speed = 30;
    private final int blockSize;

    // How many points does the player have
    private int mScore;
    private int mHighScore;

    // Objects for drawing
    private Canvas mCanvas;
    private final SurfaceHolder mSurfaceHolder;
    private final Paint mPaint;

    // Game objects
    private final Snake mSnake;
    private final Apple mApple;
    private final Ghost mGhost;

    private final Context mContext;

    TextView SnakeActivity_btnPauseOrResume;

    private TextView mTxtScore;
    private TextView mTxtHighScore;

    // Background image
    private Bitmap mBackgroundBitmap;

    public SnakeGame(Context context, Point size, TextView txtScore, TextView txtHighScore) {
        super(context);

        this.mContext = context;
        mTxtScore = txtScore;
        mTxtHighScore = txtHighScore;

        // Work out how many pixels each block is
        this.blockSize = size.x / NUM_BLOCKS_WIDE;
        // How many blocks of the same size will fit into the height
        this.mNumBlocksHigh = size.y / this.blockSize;

        // Adjust the game area to be slightly smaller than the actual size of the game area
        int adjustedLeft = (int)(NUM_BLOCKS_WIDE * 0.10);
        int adjustedTop = (int)(mNumBlocksHigh * 0.17);
        int adjustedRight = (int)(NUM_BLOCKS_WIDE * 0.945);
        int adjustedBottom = (int)(mNumBlocksHigh * 0.95);
        Point adjustedMoveRange = new Point(adjustedRight - adjustedLeft, adjustedBottom - adjustedTop);

        // Initialize the SoundPool
        AudioAttributes audioAttributes = new AudioAttributes.Builder()
                .setUsage(AudioAttributes.USAGE_MEDIA)
                .setContentType(AudioAttributes.CONTENT_TYPE_SONIFICATION)
                .build();

        mSP = new SoundPool.Builder()
                .setMaxStreams(5)
                .setAudioAttributes(audioAttributes)
                .build();
        try {
            AssetManager assetManager = context.getAssets();
            AssetFileDescriptor descriptor;

            // Prepare the sounds in memory
            descriptor = assetManager.openFd("get_apple.ogg");
            mEat_ID = mSP.load(descriptor, 0);

            descriptor = assetManager.openFd("snake_death.ogg");
            mCrashID = mSP.load(descriptor, 0);

        } catch (IOException e) {
            // Error
        }

        // Initialize the drawing objects
        mSurfaceHolder = getHolder();
        mPaint = new Paint();

        // Initialize game objects
        mApple = new Apple(context,
                adjustedMoveRange,
                blockSize);

        mSnake = new Snake(context,
                adjustedMoveRange,
                blockSize);
        mSnake.reset(size.x, size.y); // Call reset() before accessing getHeadPosition()

        // Pass the snake's head position to the Ghost constructor
        mGhost = new Ghost(context, blockSize, speed, new Rect(0, 0, size.x, size.y), mSnake.getHeadPosition());

        // Load the background image
        try {
            Bitmap originalBitmap = BitmapFactory.decodeStream(context.getAssets().open("background.png"));
            mBackgroundBitmap = getScaledBitmap(originalBitmap, size.x, size.y);
        } catch (IOException e) {
            // Handle the exception
            e.printStackTrace();
        }
    }

    private Bitmap getScaledBitmap(Bitmap originalBitmap, int newWidth, int newHeight) {
        float originalAspectRatio = (float) originalBitmap.getWidth() / originalBitmap.getHeight();
        float newAspectRatio = (float) newWidth / newHeight;

        int scaledWidth, scaledHeight;

        if (newAspectRatio > originalAspectRatio) {
            // Stretch the image to fit the height of the game area
            scaledHeight = newHeight;
            scaledWidth = (int) (newHeight * originalAspectRatio);
        } else {
            // Stretch the image to fit the width of the game area
            scaledWidth = newWidth;
            scaledHeight = (int) (newWidth / originalAspectRatio);
            // Adjust the scaledHeight to be slightly smaller
            scaledHeight = (int) (scaledHeight * 0.95); // Adjust this value to your preference
        }

        return Bitmap.createScaledBitmap(originalBitmap, scaledWidth, scaledHeight, true);
    }

    boolean playOrNot = false;

    // Handles the game loop
    @Override
    public void run() {
        while (mPlaying) {
            if (!mPaused) {
                // Update 10 times a second
                if (updateRequired()) {
                    update();
                }
            }

            draw();
        }
    }

    public boolean updateRequired() {
        final long TARGET_FPS = 10;
        final long MILLIS_PER_SECOND = 1000;

        if (mNextFrameTime <= System.currentTimeMillis()) {
            mNextFrameTime = System.currentTimeMillis()
                    + MILLIS_PER_SECOND / TARGET_FPS;
            return true;
        }

        return false;
    }

    public void update() {
        mSnake.move();
        eatApple();
        snakeDeath();
        mGhost.update();
    }

    private void eatApple() {
        int newColor = Color.BLUE;
        if (mSnake.checkDinner(mApple.getLocation())) {
            // Overloading with parameter
            mApple.spawn(newColor);
            mScore++;
            if (mHighScore < mScore) {
                mHighScore = mScore;
            }
            mSP.play(mEat_ID, 1, 1, 0, 0, 1);

            // Update the score and high score TextViews
            mTxtScore.post(() -> mTxtScore.setText("Score: " + mScore));
            mTxtHighScore.post(() -> mTxtHighScore.setText("High Score: " + mHighScore));
        }
    }

    private void snakeDeath() {
        if (mSnake.detectDeath() || mGhost.detectCollision(mSnake.getHeadBounds())) {
            mSP.play(mCrashID, 1, 1, 0, 0, 1);
            if (SnakeActivity_btnPauseOrResume != null) {
                SnakeActivity_btnPauseOrResume.setVisibility(INVISIBLE);
            }
            mPaused = true;
            mScore = 0;

            // Update the score TextView
            mTxtScore.post(() -> mTxtScore.setText("Score: " + mScore));
        }
    }

    @SuppressLint("ClickableViewAccessibility")
    @Override
    public boolean onTouchEvent(MotionEvent motionEvent) {
        if ((motionEvent.getAction() & MotionEvent.ACTION_MASK) == MotionEvent.ACTION_UP) {
            if (mPaused) {
                mPaused = false;

                StartNewGame.newGame(mSnake, mScore, playOrNot, NUM_BLOCKS_WIDE, mNumBlocksHigh, mApple, mNextFrameTime);
                SnakeActivity_btnPauseOrResume = SnakeActivity.btnPauseOrResume;

                if (SnakeActivity_btnPauseOrResume != null) {
                    SnakeActivity_btnPauseOrResume.setVisibility(VISIBLE);

                    SnakeActivity_btnPauseOrResume.setOnClickListener(v -> {
                        playOrNot = !playOrNot;
                        if (playOrNot) {
                            pause();
                            SnakeActivity_btnPauseOrResume.setText("Resume");
                        } else {
                            resume();
                            SnakeActivity_btnPauseOrResume.setText("Pause");
                        }
                    });
                }
                // Don't want to process snake direction for this tap
                return true;
            }

            // Let the Snake class handle the input
            mSnake.switchHeading(motionEvent);
        }
        return true;
    }

    // Draw the game objects on the canvas
    private void draw() {
        if (mSurfaceHolder.getSurface().isValid()) {
            mCanvas = mSurfaceHolder.lockCanvas();

            // Draw the background
            drawBackground(mCanvas);

            // Draw the apple, snake, and ghost
            mApple.draw(mCanvas, mPaint);
            mSnake.draw(mCanvas, mPaint);
            mGhost.draw(mCanvas);

            // Unlock the canvas and reveal the graphics for this frame
            mSurfaceHolder.unlockCanvasAndPost(mCanvas);
        }
    }

    private void drawBackground(Canvas canvas) {
        // Draw the background image
        canvas.drawBitmap(mBackgroundBitmap, 0, 0, null);
    }

    // Stop the thread
    public void pause() {
        mPlaying = false;
        try {
            mThread.join();
        } catch (InterruptedException e) {
            // Error
        }
    }

    // Start the thread
    public void resume() {
        mPlaying = true;
        mThread = new Thread(this);
        mThread.start();
    }
}
File: C:\Users\Admin\Projects\Emad\Assignment_Snake_Game\app\src\main\java\com\gamecodeschool\c17snake\SpriteSheet.java
package com.gamecodeschool.c17snake;

import android.content.Context;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.Rect;

public class SpriteSheet {
    private Bitmap bitmap;

    public SpriteSheet(Context context) {
        BitmapFactory.Options bitmapOptions = new BitmapFactory.Options();
        bitmapOptions.inScaled = false;

        bitmap = BitmapFactory.decodeResource(context.getResources(), R.drawable.snake_spritesheet, bitmapOptions);
    }
}
File: C:\Users\Admin\Projects\Emad\Assignment_Snake_Game\app\src\main\java\com\gamecodeschool\c17snake\StartGame.java
package com.gamecodeschool.c17snake;

import android.content.Context;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.Paint;
import android.util.Log;

import androidx.core.content.res.ResourcesCompat;

public class StartGame {
    public static void pauseGame(Paint mPaint, Canvas mCanvas, Context mContext) {
        Log.d("tag223", "paused");

        // Set the size and color of the mPaint for the text
        mPaint.setColor(Color.parseColor("#000000"));
        mPaint.setTextSize(80);
        mPaint.setTypeface(ResourcesCompat.getFont(mContext, R.font.poppins_regular));

        // Draw the message
        mCanvas.drawText("Tap to Play", 200, 200, mPaint);
    }
}
File: C:\Users\Admin\Projects\Emad\Assignment_Snake_Game\app\src\main\java\com\gamecodeschool\c17snake\StartNewGame.java
package com.gamecodeschool.c17snake;

//import static android.view.View.VISIBLE;

//import android.content.Context;
//import android.widget.TextView;

import android.graphics.Color;

public class StartNewGame {



    public static void newGame(Snake mSnake, int mScore, boolean playOrNot, int NUM_BLOCKS_WIDE, int mNumBlocksHigh, Apple mApple, long mNextFrameTime) {

        // reset the snake
        mSnake.reset(NUM_BLOCKS_WIDE, mNumBlocksHigh);
        // Get the apple ready for dinner
        mApple.spawn();
        // Reset the mScore

        mScore = 0;


        // Setup mNextFrameTime so an update can triggered
        mNextFrameTime = System.currentTimeMillis();
    }

}

